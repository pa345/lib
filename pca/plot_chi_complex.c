/*
 * plot_chi_complex.c
 *
 * Plot stream function chi using either:
 *
 * 1) qnm (complex knm) time series generated by stage2_complex
 * 2) complex spatial modes U generated by stage2_complex
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <sys/time.h>
#include <getopt.h>
#include <complex.h>

#include <gsl/gsl_math.h>
#include <gsl/gsl_vector.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_complex.h>
#include <gsl/gsl_complex_math.h>
#include <gsl/gsl_blas.h>

#include <mainlib/ml_common.h>
#include <mainlib/ml_oct.h>
#include <mainlib/ml_green_complex.h>

#include "io.h"
#include "pca.h"

void
print_chi(const char * filename, const double b, const gsl_vector_complex * u, green_complex_workspace *green_p)
{
  FILE *fp;
  double lat, lon;
  size_t n;
  gsl_vector_complex * X = gsl_vector_complex_alloc(green_p->nnm);
  gsl_vector_complex * Y = gsl_vector_complex_alloc(green_p->nnm);
  gsl_vector_complex * Z = gsl_vector_complex_alloc(green_p->nnm);

  fp = fopen(filename, "w");

  fprintf(stderr, "print_chi: writing %s...", filename);

  n = 1;
  fprintf(fp, "# Radius: %.2f km [%.2f km altitude]\n", b, b - R_EARTH_KM);
  fprintf(fp, "# Field %zu: longitude (degrees)\n", n++);
  fprintf(fp, "# Field %zu: latitude (degrees)\n", n++);
  fprintf(fp, "# Field %zu: Re chi [kA]\n", n++);
  fprintf(fp, "# Field %zu: Im chi [kA]\n", n++);
  fprintf(fp, "# Field %zu: Re BX [nT]\n", n++);
  fprintf(fp, "# Field %zu: Im BX [nT]\n", n++);
  fprintf(fp, "# Field %zu: Re BY [nT]\n", n++);
  fprintf(fp, "# Field %zu: Im BY [nT]\n", n++);
  fprintf(fp, "# Field %zu: Re BZ [nT]\n", n++);
  fprintf(fp, "# Field %zu: Im BZ [nT]\n", n++);

  for (lon = -180.0; lon <= 180.0; lon += 1.0)
    {
      double phi = lon * M_PI / 180.0;

      for (lat = -89.0; lat <= 89.0; lat += 1.0)
        {
          double theta = M_PI / 2.0 - lat * M_PI / 180.0;
          complex double chi;
          gsl_complex B_model[3];

          green_complex_ext_chi(b, theta, phi, u, &chi, green_p);

          green_complex_ext(R_EARTH_KM, theta, phi, X, Y, Z, green_p);
          gsl_blas_zdotu(u, X, &B_model[0]);
          gsl_blas_zdotu(u, Y, &B_model[1]);
          gsl_blas_zdotu(u, Z, &B_model[2]);

          fprintf(fp, "%f %f %f %f %f %f %f %f %f %f\n",
                  lon,
                  lat,
                  creal(chi),
                  cimag(chi),
                  GSL_REAL(B_model[0]),
                  GSL_IMAG(B_model[0]),
                  GSL_REAL(B_model[1]),
                  GSL_IMAG(B_model[1]),
                  GSL_REAL(B_model[2]),
                  GSL_IMAG(B_model[2]));
        }

      fprintf(fp, "\n");
    }

  fprintf(stderr, "done\n");

  fclose(fp);

  gsl_vector_complex_free(X);
  gsl_vector_complex_free(Y);
  gsl_vector_complex_free(Z);
}

int
main(int argc, char *argv[])
{
  const double R = R_EARTH_KM;
  char *output_file = "chi.txt";
  size_t nmax, mmax;
  green_complex_workspace *green_p;
  char *qnm_file = PCA_STAGE2_COMPLEX_QNM;
  gsl_matrix_complex *Q = NULL; /* q_{nm} matrix */
  gsl_matrix_complex *U = NULL; /* spatial modes matrix */
  gsl_vector_complex_view v;    /* coefficients for stream function */
  int mode_num = 0;
  double b = R_EARTH_KM + 110.0;

  while (1)
    {
      int c;
      int option_index = 0;
      static struct option long_options[] =
        {
          { "qnm_file", no_argument, NULL, 'q' },
          { "u_file", required_argument, NULL, 'u' },
          { 0, 0, 0, 0 }
        };

      c = getopt_long(argc, argv, "b:qo:t:u:", long_options, &option_index);
      if (c == -1)
        break;

      switch (c)
        {
          case 'b':
            b = atof(optarg);
            break;

          case 'q':
            fprintf(stderr, "main: reading %s...", qnm_file);
            Q = pca_read_matrix_complex(qnm_file);
            fprintf(stderr, "done (%zu-by-%zu)\n", Q->size1, Q->size2);
            break;

          case 'u':
            fprintf(stderr, "main: reading %s...", optarg);
            U = pca_read_matrix_complex(optarg);
            fprintf(stderr, "done (%zu-by-%zu)\n", U->size1, U->size2);
            break;

          case 'o':
            output_file = optarg;
            break;

          case 't':
            mode_num = atoi(optarg);
            break;

          default:
            fprintf(stderr, "Usage: %s <--qnm_file | -q> <--u_file U.bin | -u>  [-b radius (km)] [-o output_file] [-t time_idx or mode_num]\n", argv[0]);
            break;
        }
    }

  if (Q)
    {
      /* mode_num is time index */
      v = gsl_matrix_complex_column(Q, mode_num);
      fprintf(stderr, "main: time index = %d/%zu\n", mode_num, Q->size2);
    }
  else if (U)
    {
      /* mode_num is mode number */
      v = gsl_matrix_complex_column(U, mode_num);
      fprintf(stderr, "main: mode number = %d/%zu\n", mode_num, U->size2);
    }
  else
    {
      fprintf(stderr, "Usage: %s <--qnm_file | -q> <--u_file U.bin | -u>  [-b radius (km)] [-o output_file] [-t time_idx or mode_num]\n", argv[0]);
      exit(1);
    }

  fprintf(stderr, "main: reading %s...", PCA_STAGE1_DATA);
  pca_read_data(PCA_STAGE1_DATA, &nmax, &mmax, NULL, NULL);
  fprintf(stderr, "done (nmax = %zu mmax = %zu)\n", nmax, mmax);

  green_p = green_complex_alloc(nmax, mmax, R);

  print_chi(output_file, b, &v.vector, green_p);

  green_complex_free(green_p);

  return 0;
}
